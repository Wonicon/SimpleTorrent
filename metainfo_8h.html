<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SimpleTorrent: metainfo.h 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleTorrent
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="pages.html"><span>相关页面</span></a></li>
      <li><a href="annotated.html"><span>结构体</span></a></li>
      <li class="current"><a href="files.html"><span>文件</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>文件列表</span></a></li>
      <li><a href="globals.html"><span>全局定义</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">结构体</a> &#124;
<a href="#define-members">宏定义</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">metainfo.h 文件参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>操作全局信息的相关 API 声明  
<a href="#details">更多...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
metainfo.h 的引用(Include)关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h__incl.png" border="0" usemap="#metainfo_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
此图展示该文件直接或间接的被哪些文件引用了:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h__dep__incl.png" border="0" usemap="#metainfo_8hdep" alt=""/></div>
<map name="metainfo_8hdep" id="metainfo_8hdep">
<area shape="rect" id="node2" href="butil_8c.html" title="基于 B 编码语法树的工具函数实现 " alt="" coords="5,80,63,107"/>
<area shape="rect" id="node3" href="connect_8c.html" title="网络连接相关 API 实现 " alt="" coords="87,80,165,107"/>
<area shape="rect" id="node4" href="peer_8h.html" title="单个 peer 相关操作 API 声明 " alt="" coords="190,80,249,107"/>
<area shape="rect" id="node6" href="metainfo_8c.html" title="操作全局信息的相关 API 实现 " alt="" coords="265,155,347,181"/>
<area shape="rect" id="node5" href="driver_8c.html" title="顶层驱动模块 " alt="" coords="92,155,157,181"/>
<area shape="rect" id="node7" href="peer_8c.html" title="单个 peer 相关操作 API 实现 " alt="" coords="182,155,241,181"/>
</map>
</div>
</div>
<p><a href="metainfo_8h_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
结构体</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTracker.html">Tracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">描述 tracker 的相关信息  <a href="structTracker.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPieceInfo.html">PieceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">分片信息  <a href="structPieceInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWaitPeer.html">WaitPeer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">描述处于等待握手状态的 peer 信息  <a href="structWaitPeer.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMetaInfo.html">MetaInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">描述一次运行的全局信息  <a href="structMetaInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
宏定义</h2></td></tr>
<tr class="memitem:ad6074dd11ab3c97c8135c43aab03ae95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6074dd11ab3c97c8135c43aab03ae95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#ad6074dd11ab3c97c8135c43aab03ae95">HASH_SIZE</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:ad6074dd11ab3c97c8135c43aab03ae95"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA1 HASH 的字节数 <br /></td></tr>
<tr class="separator:ad6074dd11ab3c97c8135c43aab03ae95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa8612f0ffb51e32675472d734916f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#ae3fa8612f0ffb51e32675472d734916f">SUB_NA</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ae3fa8612f0ffb51e32675472d734916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd2c385d0547cc5a057213a71021b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a02dd2c385d0547cc5a057213a71021b0">SUB_DOWNLOAD</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a02dd2c385d0547cc5a057213a71021b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c26e6dc0c142ca0b1d664872211af0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a4c26e6dc0c142ca0b1d664872211af0d">SUB_FINISH</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a4c26e6dc0c142ca0b1d664872211af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbfdc2d7f8546e0163931ecb3a926b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a9fbfdc2d7f8546e0163931ecb3a926b5">WAIT_THRESHOLD</a>&#160;&#160;&#160;10.0</td></tr>
<tr class="separator:a9fbfdc2d7f8546e0163931ecb3a926b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ae9639692cbf4a51735c6365ad35b904a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9639692cbf4a51735c6365ad35b904a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#ae9639692cbf4a51735c6365ad35b904a">free_metainfo</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> **pmi)</td></tr>
<tr class="memdesc:ae9639692cbf4a51735c6365ad35b904a"><td class="mdescLeft">&#160;</td><td class="mdescRight">释放全局信息 <br /></td></tr>
<tr class="separator:ae9639692cbf4a51735c6365ad35b904a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8859c576edfc642ef89d66984d0d531f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a8859c576edfc642ef89d66984d0d531f">extract_trackers</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, const struct <a class="el" href="structBNode.html">BNode</a> *ast)</td></tr>
<tr class="memdesc:a8859c576edfc642ef89d66984d0d531f"><td class="mdescLeft">&#160;</td><td class="mdescRight">提取 tracker 列表  <a href="#a8859c576edfc642ef89d66984d0d531f">更多...</a><br /></td></tr>
<tr class="separator:a8859c576edfc642ef89d66984d0d531f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108b01c970e97953b9430fe80cc571dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a108b01c970e97953b9430fe80cc571dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a108b01c970e97953b9430fe80cc571dd">metainfo_load_file</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, const struct <a class="el" href="structBNode.html">BNode</a> *ast)</td></tr>
<tr class="memdesc:a108b01c970e97953b9430fe80cc571dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取文件名，读取文件，分析已经完成的块 <br /></td></tr>
<tr class="separator:a108b01c970e97953b9430fe80cc571dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9920b3ee23e92c773734e1a7d1c4bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#af9920b3ee23e92c773734e1a7d1c4bc5">extract_pieces</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, const struct <a class="el" href="structBNode.html">BNode</a> *ast)</td></tr>
<tr class="memdesc:af9920b3ee23e92c773734e1a7d1c4bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">提取分片 hash  <a href="#af9920b3ee23e92c773734e1a7d1c4bc5">更多...</a><br /></td></tr>
<tr class="separator:af9920b3ee23e92c773734e1a7d1c4bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa5e284ddbc9416dae702f86396d1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a7fa5e284ddbc9416dae702f86396d1f4">add_peer</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, struct <a class="el" href="structPeer.html">Peer</a> *p)</td></tr>
<tr class="memdesc:a7fa5e284ddbc9416dae702f86396d1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">增加一个 peer  <a href="#a7fa5e284ddbc9416dae702f86396d1f4">更多...</a><br /></td></tr>
<tr class="separator:a7fa5e284ddbc9416dae702f86396d1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad389a17acedda88f7ec07f3d1fe16d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#ad389a17acedda88f7ec07f3d1fe16d13">del_peer_by_fd</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int fd)</td></tr>
<tr class="memdesc:ad389a17acedda88f7ec07f3d1fe16d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据连接套接字删除 peer  <a href="#ad389a17acedda88f7ec07f3d1fe16d13">更多...</a><br /></td></tr>
<tr class="separator:ad389a17acedda88f7ec07f3d1fe16d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bb5a89206b2839221a6fbdcc76391"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structPeer.html">Peer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a6a1bb5a89206b2839221a6fbdcc76391">get_peer_by_fd</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int fd)</td></tr>
<tr class="memdesc:a6a1bb5a89206b2839221a6fbdcc76391"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据连接套接字搜索 peer  <a href="#a6a1bb5a89206b2839221a6fbdcc76391">更多...</a><br /></td></tr>
<tr class="separator:a6a1bb5a89206b2839221a6fbdcc76391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe90ddb8114d95960e645b74c4a3596"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structPeer.html">Peer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#acfe90ddb8114d95960e645b74c4a3596">get_peer_by_addr</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, uint32_t addr, uint16_t port)</td></tr>
<tr class="memdesc:acfe90ddb8114d95960e645b74c4a3596"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据网络地址搜索 peer  <a href="#acfe90ddb8114d95960e645b74c4a3596">更多...</a><br /></td></tr>
<tr class="separator:acfe90ddb8114d95960e645b74c4a3596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca18a112ba5197130cc7770ce5efc85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a0ca18a112ba5197130cc7770ce5efc85">check_substate</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int index)</td></tr>
<tr class="memdesc:a0ca18a112ba5197130cc7770ce5efc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查某一分片的子分片状态并打印  <a href="#a0ca18a112ba5197130cc7770ce5efc85">更多...</a><br /></td></tr>
<tr class="separator:a0ca18a112ba5197130cc7770ce5efc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a06061e6a4ba654b3a279a377eca47"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structTracker.html">Tracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a98a06061e6a4ba654b3a279a377eca47">get_tracker_by_fd</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int sfd)</td></tr>
<tr class="memdesc:a98a06061e6a4ba654b3a279a377eca47"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据连接套接字找 tracker  <a href="#a98a06061e6a4ba654b3a279a377eca47">更多...</a><br /></td></tr>
<tr class="separator:a98a06061e6a4ba654b3a279a377eca47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa744e37bc7247a42651e5e275a75bf10"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structTracker.html">Tracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#aa744e37bc7247a42651e5e275a75bf10">get_tracker_by_timer</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int timerfd)</td></tr>
<tr class="memdesc:aa744e37bc7247a42651e5e275a75bf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据定时器描述符找 tracker  <a href="#aa744e37bc7247a42651e5e275a75bf10">更多...</a><br /></td></tr>
<tr class="separator:aa744e37bc7247a42651e5e275a75bf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99194ac1d61e6cd9dd6d3c506abc2ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99194ac1d61e6cd9dd6d3c506abc2ae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a99194ac1d61e6cd9dd6d3c506abc2ae7">add_wait_peer</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int fd, uint32_t addr, uint16_t port)</td></tr>
<tr class="memdesc:a99194ac1d61e6cd9dd6d3c506abc2ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加等待 peer, 网络字节序 <br /></td></tr>
<tr class="separator:a99194ac1d61e6cd9dd6d3c506abc2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5630c31340a960849e709464be6c81ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a5630c31340a960849e709464be6c81ab">get_wait_peer_index_by_fd</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int fd)</td></tr>
<tr class="memdesc:a5630c31340a960849e709464be6c81ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据套接字找到 peer 下标  <a href="#a5630c31340a960849e709464be6c81ab">更多...</a><br /></td></tr>
<tr class="separator:a5630c31340a960849e709464be6c81ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15a761a62ea1fb810f8caac1d4e2e46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#ae15a761a62ea1fb810f8caac1d4e2e46">find_wait_peer_fd_by_addr</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, uint32_t addr, uint16_t port)</td></tr>
<tr class="memdesc:ae15a761a62ea1fb810f8caac1d4e2e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据地址找到 peer 的套接字，网络字节序  <a href="#ae15a761a62ea1fb810f8caac1d4e2e46">更多...</a><br /></td></tr>
<tr class="separator:ae15a761a62ea1fb810f8caac1d4e2e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73883a857c3bba4acf63aad4ebd53018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metainfo_8h.html#a73883a857c3bba4acf63aad4ebd53018">rm_wait_peer</a> (struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *mi, int index)</td></tr>
<tr class="memdesc:a73883a857c3bba4acf63aad4ebd53018"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除等待 peer  <a href="#a73883a857c3bba4acf63aad4ebd53018">更多...</a><br /></td></tr>
<tr class="separator:a73883a857c3bba4acf63aad4ebd53018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>操作全局信息的相关 API 声明 </p>
</div><h2 class="groupheader">宏定义说明</h2>
<a class="anchor" id="a02dd2c385d0547cc5a057213a71021b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SUB_DOWNLOAD&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>子分片下载中 </p>

</div>
</div>
<a class="anchor" id="a4c26e6dc0c142ca0b1d664872211af0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SUB_FINISH&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>子分片完成下载 </p>

</div>
</div>
<a class="anchor" id="ae3fa8612f0ffb51e32675472d734916f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SUB_NA&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>子分片没有开始下载 </p>

</div>
</div>
<a class="anchor" id="a9fbfdc2d7f8546e0163931ecb3a926b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WAIT_THRESHOLD&#160;&#160;&#160;10.0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>子分片最长等待时间 10s </p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a class="anchor" id="a7fa5e284ddbc9416dae702f86396d1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_peer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structPeer.html">Peer</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>增加一个 peer </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">p</td><td>要加入的 peer, 要求是动态分配的. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a7fa5e284ddbc9416dae702f86396d1f4_icgraph.png" border="0" usemap="#metainfo_8h_a7fa5e284ddbc9416dae702f86396d1f4_icgraph" alt=""/></div>
<map name="metainfo_8h_a7fa5e284ddbc9416dae702f86396d1f4_icgraph" id="metainfo_8h_a7fa5e284ddbc9416dae702f86396d1f4_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a23d49f290a81bbd360baac95364fbef9" title="完成握手消息的处理 " alt="" coords="128,5,251,32"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="299,5,381,32"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="429,5,480,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ca18a112ba5197130cc7770ce5efc85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_substate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>检查某一分片的子分片状态并打印 </p>
<p>打印符号说明：</p><ol type="1">
<li>. 已完成</li>
<li>0 正下载</li>
<li>X 未下载</li>
</ol>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">index</td><td>分片号 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果全部子分片完成返回 1, 否则返回 0. </dd></dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a0ca18a112ba5197130cc7770ce5efc85_icgraph.png" border="0" usemap="#metainfo_8h_a0ca18a112ba5197130cc7770ce5efc85_icgraph" alt=""/></div>
<map name="metainfo_8h_a0ca18a112ba5197130cc7770ce5efc85_icgraph" id="metainfo_8h_a0ca18a112ba5197130cc7770ce5efc85_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a1144015b47fb80b2a0faf9fe01bd6d02" title="选择需要请求的分片 " alt="" coords="315,5,409,32"/>
<area shape="rect" id="node5" href="driver_8c.html#a84c804ac82d6ab32fe4c37310c2c8cb8" title="处理分片消息 " alt="" coords="168,56,267,83"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="457,31,540,57"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="588,31,639,57"/>
<area shape="rect" id="node6" href="driver_8c.html#adbae4421b9be5243d3f1773cf525292b" title="处理 BT 消息 " alt="" coords="316,56,408,83"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad389a17acedda88f7ec07f3d1fe16d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void del_peer_by_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据连接套接字删除 peer </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">fd</td><td>连接套接字描述符</td></tr>
  </table>
  </dd>
</dl>
<p>被删除的指针空闲没有回收, 在未来增加新 peer 时靠 realloc 重新尾部的冗余空间. </p>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_ad389a17acedda88f7ec07f3d1fe16d13_icgraph.png" border="0" usemap="#metainfo_8h_ad389a17acedda88f7ec07f3d1fe16d13_icgraph" alt=""/></div>
<map name="metainfo_8h_ad389a17acedda88f7ec07f3d1fe16d13_icgraph" id="metainfo_8h_ad389a17acedda88f7ec07f3d1fe16d13_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="164,5,247,32"/>
<area shape="rect" id="node3" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="295,5,345,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af9920b3ee23e92c773734e1a7d1c4bc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_pieces </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structBNode.html">BNode</a> *&#160;</td>
          <td class="paramname"><em>ast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>提取分片 hash </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">ast</td><td>B 编码语法树 </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_af9920b3ee23e92c773734e1a7d1c4bc5_icgraph.png" border="0" usemap="#metainfo_8h_af9920b3ee23e92c773734e1a7d1c4bc5_icgraph" alt=""/></div>
<map name="metainfo_8h_af9920b3ee23e92c773734e1a7d1c4bc5_icgraph" id="metainfo_8h_af9920b3ee23e92c773734e1a7d1c4bc5_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="160,5,211,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8859c576edfc642ef89d66984d0d531f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_trackers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structBNode.html">BNode</a> *&#160;</td>
          <td class="paramname"><em>ast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>提取 tracker 列表 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">ast</td><td>B 编码语法树</td></tr>
  </table>
  </dd>
</dl>
<p>观察实际的种子文件, 发现如果有 announce-list, 那么 announce 往往是其中的第一项. 但是 announce-list 本身 不是必须的, 所以在没有 announce-list 是解析 announce 否则直接使用 announce-list 忽略 announce. </p>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a8859c576edfc642ef89d66984d0d531f_icgraph.png" border="0" usemap="#metainfo_8h_a8859c576edfc642ef89d66984d0d531f_icgraph" alt=""/></div>
<map name="metainfo_8h_a8859c576edfc642ef89d66984d0d531f_icgraph" id="metainfo_8h_a8859c576edfc642ef89d66984d0d531f_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="169,5,220,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae15a761a62ea1fb810f8caac1d4e2e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_wait_peer_fd_by_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据地址找到 peer 的套接字，网络字节序 </p>
<dl class="section return"><dt>返回</dt><dd>对应的套接字，没找到则 -1. </dd></dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_ae15a761a62ea1fb810f8caac1d4e2e46_icgraph.png" border="0" usemap="#metainfo_8h_ae15a761a62ea1fb810f8caac1d4e2e46_icgraph" alt=""/></div>
<map name="metainfo_8h_ae15a761a62ea1fb810f8caac1d4e2e46_icgraph" id="metainfo_8h_ae15a761a62ea1fb810f8caac1d4e2e46_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a288da41ae0ddeca593e7604471ed184e" title="将 tracker 返回的 peers 异步 connect 并加入 epoll 队列 " alt="" coords="231,5,347,32"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="395,5,477,32"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="525,5,576,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acfe90ddb8114d95960e645b74c4a3596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structPeer.html">Peer</a>* get_peer_by_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据网络地址搜索 peer </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">addr</td><td>ip 地址，网络字节序 </td></tr>
    <tr><td class="paramname">port</td><td>端口号，网络字节序</td></tr>
  </table>
  </dd>
</dl>
<p>参数的 addr 和 port 是网络字节序。 peer 自己的 addr 在构造时是网络字节序，但是 port 是本机字节序。 </p>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_acfe90ddb8114d95960e645b74c4a3596_icgraph.png" border="0" usemap="#metainfo_8h_acfe90ddb8114d95960e645b74c4a3596_icgraph" alt=""/></div>
<map name="metainfo_8h_acfe90ddb8114d95960e645b74c4a3596_icgraph" id="metainfo_8h_acfe90ddb8114d95960e645b74c4a3596_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a288da41ae0ddeca593e7604471ed184e" title="将 tracker 返回的 peers 异步 connect 并加入 epoll 队列 " alt="" coords="179,5,295,32"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="343,5,425,32"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="473,5,524,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6a1bb5a89206b2839221a6fbdcc76391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structPeer.html">Peer</a>* get_peer_by_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据连接套接字搜索 peer </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">fd</td><td>连接套接字描述符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>找到时返回对应的 peer 指针, 否则返回 NULL.</dd></dl>
<p>适用于 epoll 场景, 此时套接字描述符是最先确定的数据. </p>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a6a1bb5a89206b2839221a6fbdcc76391_icgraph.png" border="0" usemap="#metainfo_8h_a6a1bb5a89206b2839221a6fbdcc76391_icgraph" alt=""/></div>
<map name="metainfo_8h_a6a1bb5a89206b2839221a6fbdcc76391_icgraph" id="metainfo_8h_a6a1bb5a89206b2839221a6fbdcc76391_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="164,5,247,32"/>
<area shape="rect" id="node3" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="295,5,345,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a98a06061e6a4ba654b3a279a377eca47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structTracker.html">Tracker</a>* get_tracker_by_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据连接套接字找 tracker </p>
<p>适用于第一手信息是套接字的场合: epoll</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">sfd</td><td>连接套接字 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的 tracker 指针，没找到返回 NULL </dd></dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a98a06061e6a4ba654b3a279a377eca47_icgraph.png" border="0" usemap="#metainfo_8h_a98a06061e6a4ba654b3a279a377eca47_icgraph" alt=""/></div>
<map name="metainfo_8h_a98a06061e6a4ba654b3a279a377eca47_icgraph" id="metainfo_8h_a98a06061e6a4ba654b3a279a377eca47_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a24ba120aedfee26e7bfde8e2f72449ff" title="处理出错套接字 " alt="" coords="183,5,276,32"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="327,56,409,83"/>
<area shape="rect" id="node5" href="driver_8c.html#a0017b9340d4b1cca06a57ab102b09034" title="执行连接建立后的相关操作 " alt="" coords="180,107,279,133"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="457,56,508,83"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa744e37bc7247a42651e5e275a75bf10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structTracker.html">Tracker</a>* get_tracker_by_timer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timerfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据定时器描述符找 tracker </p>
<p>定时事件是一个低频事件，所以这个函数在 EPOLLIN 事件里排在最后</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>全局信息 </td></tr>
    <tr><td class="paramname">timerfd</td><td>定时器描述符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的 tracker 指针，没找到返回 NULL </dd></dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_aa744e37bc7247a42651e5e275a75bf10_icgraph.png" border="0" usemap="#metainfo_8h_aa744e37bc7247a42651e5e275a75bf10_icgraph" alt=""/></div>
<map name="metainfo_8h_aa744e37bc7247a42651e5e275a75bf10_icgraph" id="metainfo_8h_aa744e37bc7247a42651e5e275a75bf10_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="197,5,280,32"/>
<area shape="rect" id="node3" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="328,5,379,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5630c31340a960849e709464be6c81ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_wait_peer_index_by_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>根据套接字找到 peer 下标 </p>
<dl class="section return"><dt>返回</dt><dd>对应的下标，没找到则 -1. </dd></dl>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a5630c31340a960849e709464be6c81ab_icgraph.png" border="0" usemap="#metainfo_8h_a5630c31340a960849e709464be6c81ab_icgraph" alt=""/></div>
<map name="metainfo_8h_a5630c31340a960849e709464be6c81ab_icgraph" id="metainfo_8h_a5630c31340a960849e709464be6c81ab_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a24ba120aedfee26e7bfde8e2f72449ff" title="处理出错套接字 " alt="" coords="209,5,303,32"/>
<area shape="rect" id="node5" href="driver_8c.html#a23d49f290a81bbd360baac95364fbef9" title="完成握手消息的处理 " alt="" coords="195,56,317,83"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="365,31,448,57"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="496,31,547,57"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a73883a857c3bba4acf63aad4ebd53018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rm_wait_peer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structMetaInfo.html">MetaInfo</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除等待 peer </p>
<p>如果要删除的元素刚好是最后一个，只需要减少总数量就行了。 </p>

<p><div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="metainfo_8h_a73883a857c3bba4acf63aad4ebd53018_icgraph.png" border="0" usemap="#metainfo_8h_a73883a857c3bba4acf63aad4ebd53018_icgraph" alt=""/></div>
<map name="metainfo_8h_a73883a857c3bba4acf63aad4ebd53018_icgraph" id="metainfo_8h_a73883a857c3bba4acf63aad4ebd53018_icgraph">
<area shape="rect" id="node2" href="driver_8c.html#a24ba120aedfee26e7bfde8e2f72449ff" title="处理出错套接字 " alt="" coords="168,5,261,32"/>
<area shape="rect" id="node5" href="driver_8c.html#a23d49f290a81bbd360baac95364fbef9" title="完成握手消息的处理 " alt="" coords="153,56,276,83"/>
<area shape="rect" id="node3" href="driver_8c.html#aa93c0218730a095b7930ba739b40ee70" title="处理所有网络报文 " alt="" coords="324,31,407,57"/>
<area shape="rect" id="node4" href="driver_8c.html#a0ddf1224851353fc92bfbff6f499fa97" title="入口函数，完成种子文件的解析，全局信息的生成以及进入消息处理逻辑。 " alt="" coords="455,31,505,57"/>
</map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
